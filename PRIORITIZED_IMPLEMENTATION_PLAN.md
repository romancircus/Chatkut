# ChatKut - Prioritized Implementation Plan

**Created:** 2025-11-08
**Based On:** Documentation-Driven Gap Analysis V2.0
**Context:** ~85% complete codebase with critical integration gaps

---

## Executive Summary

**Current State:**
- ‚úÖ Backend foundation 100% complete (Convex schema, types, basic infrastructure)
- ‚úÖ Composition engine 100% complete (selectors, executor, compiler)
- ‚úÖ Frontend components 90% complete (missing Timeline UI)
- ‚úÖ 49 Playwright tests implemented
- ‚úÖ Official documentation ingested (Remotion, Convex, Next.js)

**Critical Gaps Identified:**
1. **Environment Variables** - Using wrong approach for Convex cloud
2. **Cloudflare Integration** - Missing TUS protocol details & security
3. **AI SDK** - Dedalus placeholder only (throws error)
4. **Remotion Cost** - Mock estimation instead of official API
5. **Next.js Patterns** - Not using async server components

**Time to Production:** ~6 hours of focused implementation

---

## Phase 1: CRITICAL FIXES (Must Fix Before Any Testing)

### Task 1.1: Fix Convex Environment Variables Architecture ‚è±Ô∏è 30 minutes

**Priority:** üî¥ CRITICAL - Blocks all external integrations

**Problem:**
Current code assumes Convex cloud functions can read `.env.local`, but they cannot. All Convex actions (media.ts, ai.ts, rendering.ts) will fail in production.

**What to Fix:**

1. **Update `.env.example`** with clear distinction:

```bash
# ===================================================================
# CONVEX BACKEND ENVIRONMENT VARIABLES (Convex Cloud)
# ===================================================================
# These variables are ONLY accessible from convex/*.ts files
# They run in Convex's cloud infrastructure, NOT in Next.js
#
# ‚ö†Ô∏è IMPORTANT: DO NOT put these in .env.local - they will be ignored!
#
# Set these using the Convex CLI:
#   npx convex env set VARIABLE_NAME "value"
#
# View all set variables:
#   npx convex env list
# ===================================================================

# Cloudflare Stream (for video uploads)
CLOUDFLARE_ACCOUNT_ID=your-cloudflare-account-id
CLOUDFLARE_STREAM_API_TOKEN=your-stream-api-token

# Cloudflare R2 (for image/file storage)
CLOUDFLARE_R2_ACCESS_KEY_ID=your-r2-access-key
CLOUDFLARE_R2_SECRET_ACCESS_KEY=your-r2-secret-key
CLOUDFLARE_R2_ENDPOINT=https://xxx.r2.cloudflarestorage.com
CLOUDFLARE_R2_BUCKET_NAME=chatkut-media

# Cloudflare Webhooks
CLOUDFLARE_WEBHOOK_SECRET=your-webhook-secret

# Dedalus AI
DEDALUS_API_KEY=your-dedalus-api-key

# Remotion Lambda
REMOTION_AWS_REGION=us-east-1
REMOTION_FUNCTION_NAME=remotion-render-lambda
REMOTION_AWS_ACCESS_KEY_ID=your-aws-access-key
REMOTION_AWS_SECRET_ACCESS_KEY=your-aws-secret

# ===================================================================
# NEXT.JS FRONTEND ENVIRONMENT VARIABLES (.env.local)
# ===================================================================
# These variables are for Next.js server/client code (app/*, components/*)
# Put these in .env.local (auto-generated by npx convex dev)
# ===================================================================

# Convex (auto-generated, do not edit)
CONVEX_DEPLOYMENT=dev:xxx
NEXT_PUBLIC_CONVEX_URL=https://xxx.convex.cloud

# Optional: Authentication (if using Clerk)
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_xxx
CLERK_SECRET_KEY=sk_test_xxx
```

2. **Update README.md Setup Instructions**

Add this section after "Install dependencies":

```markdown
### Set Up Environment Variables

**IMPORTANT:** ChatKut uses two separate environments:
- **Convex Backend** (cloud functions) - Set via CLI
- **Next.js Frontend** (browser/SSR) - Set in `.env.local`

#### Step 1: Convex Backend Variables (REQUIRED)

Run these commands to configure Convex cloud environment:

```bash
# Cloudflare credentials
npx convex env set CLOUDFLARE_ACCOUNT_ID "your-account-id"
npx convex env set CLOUDFLARE_STREAM_API_TOKEN "your-token"
npx convex env set CLOUDFLARE_R2_ACCESS_KEY_ID "your-key"
npx convex env set CLOUDFLARE_R2_SECRET_ACCESS_KEY "your-secret"
npx convex env set CLOUDFLARE_R2_ENDPOINT "https://xxx.r2.cloudflarestorage.com"
npx convex env set CLOUDFLARE_R2_BUCKET_NAME "chatkut-media"
npx convex env set CLOUDFLARE_WEBHOOK_SECRET "your-webhook-secret"

# Dedalus AI
npx convex env set DEDALUS_API_KEY "your-dedalus-key"

# Remotion Lambda (if using cloud rendering)
npx convex env set REMOTION_AWS_REGION "us-east-1"
npx convex env set REMOTION_FUNCTION_NAME "remotion-render-lambda"
npx convex env set REMOTION_AWS_ACCESS_KEY_ID "your-aws-key"
npx convex env set REMOTION_AWS_SECRET_ACCESS_KEY "your-aws-secret"

# Verify variables are set
npx convex env list
```

#### Step 2: Next.js Variables

The `npx convex dev` command auto-generates `.env.local` with Convex connection details. Optionally add auth credentials:

```bash
# Optional: Add to .env.local if using Clerk
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_xxx
CLERK_SECRET_KEY=sk_test_xxx
```
```

3. **Test Environment Variable Access**

Create test script: `scripts/test-convex-env.ts`

```typescript
import { action } from "./_generated/server";

export const testEnvVars = action({
  handler: async () => {
    const requiredVars = [
      "CLOUDFLARE_ACCOUNT_ID",
      "CLOUDFLARE_STREAM_API_TOKEN",
      "DEDALUS_API_KEY",
    ];

    const results: Record<string, boolean> = {};

    for (const varName of requiredVars) {
      const value = process.env[varName];
      results[varName] = !!value;
      console.log(`[test] ${varName}: ${value ? "‚úÖ SET" : "‚ùå MISSING"}`);
    }

    return results;
  },
});
```

**Acceptance Criteria:**
- [ ] `.env.example` clearly documents Convex vs Next.js variables
- [ ] README.md has step-by-step CLI setup instructions
- [ ] Test action confirms all required vars are accessible
- [ ] No references to `.env.local` for Convex backend code

**Files to Update:**
- `.env.example`
- `README.md`
- `convex/testEnvVars.ts` (new)

---

### Task 1.2: Implement Cloudflare Upload Integration ‚è±Ô∏è 3 hours

**Priority:** üî¥ CRITICAL - Core feature (video upload)

**Problem:**
Current implementation missing:
- Full TUS protocol implementation
- Webhook signature verification (security risk!)
- Proper error handling
- Metadata formatting

**What to Fix:**

1. **Update `convex/media.ts` - TUS Upload Request**

```typescript
import { action } from "./_generated/server";
import { internal } from "./_generated/api";
import { v } from "convex/values";

export const requestStreamUploadUrl = action({
  args: {
    projectId: v.id("projects"),
    filename: v.string(),
    fileSize: v.number(),
  },
  handler: async (ctx, { projectId, filename, fileSize }) => {
    const ACCOUNT_ID = process.env.CLOUDFLARE_ACCOUNT_ID;
    const API_TOKEN = process.env.CLOUDFLARE_STREAM_API_TOKEN;

    if (!ACCOUNT_ID || !API_TOKEN) {
      console.error("[media:requestUpload] Missing Cloudflare credentials");
      throw new Error(
        "Cloudflare not configured. Run: npx convex env set CLOUDFLARE_ACCOUNT_ID \"your-id\""
      );
    }

    console.log("[media:requestUpload] Requesting TUS upload URL:", {
      projectId,
      filename,
      fileSize,
    });

    // Step 1: Request TUS upload URL from Cloudflare Stream
    const response = await fetch(
      `https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/stream/direct_upload`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${API_TOKEN}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          maxDurationSeconds: 3600,
          meta: {
            projectId,
            filename,
          },
          requireSignedURLs: false,
          uploadCreator: "chatkut-app",
        }),
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      console.error("[media:requestUpload] Cloudflare API error:", {
        status: response.status,
        error: errorText,
      });
      throw new Error(
        `Cloudflare Stream API error (${response.status}): ${errorText}`
      );
    }

    const data = await response.json();

    console.log("[media:requestUpload] Got TUS URL:", {
      uploadURL: data.result.uploadURL,
      uid: data.result.uid,
    });

    // Step 2: Create asset record in Convex
    const assetId = await ctx.runMutation(internal.media.createAsset, {
      projectId,
      filename,
      type: "video",
      status: "uploading",
      streamId: data.result.uid,
      uploadUrl: data.result.uploadURL,
      fileSize,
    });

    console.log("[media:requestUpload] Created asset record:", assetId);

    return {
      assetId,
      uploadUrl: data.result.uploadURL,
      streamId: data.result.uid,
    };
  },
});
```

2. **Update Webhook Handler with Signature Verification**

```typescript
import { httpAction } from "./_generated/server";
import { internal } from "./_generated/api";
import { Webhook } from "svix";

export const handleStreamWebhook = httpAction(async (ctx, request) => {
  const WEBHOOK_SECRET = process.env.CLOUDFLARE_WEBHOOK_SECRET;
  const ACCOUNT_ID = process.env.CLOUDFLARE_ACCOUNT_ID;

  if (!WEBHOOK_SECRET) {
    console.error("[media:webhook] CLOUDFLARE_WEBHOOK_SECRET not set");
    return new Response("Webhook secret not configured", { status: 500 });
  }

  console.log("[media:webhook] Received webhook");

  // Step 1: Verify webhook signature
  const payloadString = await request.text();
  const svixHeaders = {
    "svix-id": request.headers.get("svix-id"),
    "svix-timestamp": request.headers.get("svix-timestamp"),
    "svix-signature": request.headers.get("svix-signature"),
  };

  if (!svixHeaders["svix-id"] || !svixHeaders["svix-timestamp"] || !svixHeaders["svix-signature"]) {
    console.error("[media:webhook] Missing svix headers");
    return new Response("Missing required headers", { status: 400 });
  }

  let event: any;

  try {
    const wh = new Webhook(WEBHOOK_SECRET);
    event = wh.verify(payloadString, svixHeaders);
    console.log("[media:webhook] Signature verified ‚úì");
  } catch (error) {
    console.error("[media:webhook] Signature verification failed:", error);
    return new Response("Unauthorized", { status: 401 });
  }

  // Step 2: Handle event based on status
  console.log("[media:webhook] Event:", {
    status: event.status,
    uid: event.uid,
  });

  if (event.status === "ready") {
    const playbackUrl = `https://customer-${ACCOUNT_ID}.cloudflarestream.com/${event.uid}/manifest/video.m3u8`;

    await ctx.runMutation(internal.media.updateAssetStatus, {
      streamId: event.uid,
      status: "ready",
      playbackUrl,
      duration: event.duration || 0,
    });

    console.log("[media:webhook] Asset marked ready:", {
      streamId: event.uid,
      playbackUrl,
    });
  } else if (event.status === "error") {
    await ctx.runMutation(internal.media.updateAssetStatus, {
      streamId: event.uid,
      status: "error",
    });

    console.log("[media:webhook] Asset marked error:", event.uid);
  }

  return new Response(null, { status: 200 });
});
```

3. **Install Svix Package**

```bash
npm install svix
```

4. **Test Upload Flow**

Create test script: `scripts/test-upload.ts`

**Acceptance Criteria:**
- [ ] TUS upload request returns valid uploadURL
- [ ] Webhook signature verification works
- [ ] Asset status updates to "ready" after processing
- [ ] HLS playback URL is accessible
- [ ] Error handling for invalid credentials

**Files to Update:**
- `convex/media.ts`
- `package.json` (add svix)

---

### Task 1.3: Implement Dedalus SDK Integration ‚è±Ô∏è 2 hours

**Priority:** üî¥ CRITICAL - AI features don't work without this

**Problem:**
Current `lib/dedalus/client.ts` throws error "not configured". All AI actions (chat, edit plan generation, code generation) will fail.

**What to Fix:**

1. **Install Dedalus SDK**

```bash
npm install dedalus-labs
```

2. **Implement `lib/dedalus/client.ts`**

```typescript
import { AsyncDedalus } from "dedalus-labs";

// Model routing configuration
export const MODEL_ROUTING = {
  "chat-response": {
    provider: "openai" as const,
    model: "gpt-4o",
    temperature: 0.7,
  },
  "plan-generation": {
    provider: "anthropic" as const,
    model: "claude-sonnet-4",
    temperature: 0.3, // Low for determinism
  },
  "code-generation": {
    provider: "anthropic" as const,
    model: "claude-sonnet-4",
    temperature: 0.3,
  },
} as const;

let dedalusClient: AsyncDedalus | null = null;

export function getAIClient(apiKey: string): AsyncDedalus {
  if (!apiKey) {
    throw new Error(
      "DEDALUS_API_KEY not configured. Run: npx convex env set DEDALUS_API_KEY \"your-key\""
    );
  }

  if (!dedalusClient) {
    dedalusClient = new AsyncDedalus({
      apiKey,
    });
  }

  return dedalusClient;
}

export async function generateChatResponse(
  apiKey: string,
  message: string,
  context: {
    assets: any[];
    composition: any;
    history: any[];
  }
) {
  const client = getAIClient(apiKey);
  const systemPrompt = buildChatSystemPrompt(context);

  console.log("[dedalus:chat] Generating response for:", message.slice(0, 50));

  const response = await client.generateText({
    task: "chat-response",
    systemPrompt,
    prompt: message,
    temperature: MODEL_ROUTING["chat-response"].temperature,
    maxTokens: 1000,
  });

  console.log("[dedalus:chat] Response generated:", {
    model: response.model,
    provider: response.provider,
    tokens: response.tokenUsage?.total || 0,
    cost: response.cost || 0,
  });

  return {
    text: response.text,
    model: response.model,
    provider: response.provider,
    cost: response.cost,
    tokens: response.tokenUsage,
  };
}

export async function generateEditPlan(
  apiKey: string,
  userMessage: string,
  compositionIR: any
) {
  const client = getAIClient(apiKey);
  const systemPrompt = buildEditPlanSystemPrompt(compositionIR);

  console.log("[dedalus:plan] Generating edit plan for:", userMessage.slice(0, 50));

  const response = await client.generateJSON({
    task: "plan-generation",
    systemPrompt,
    prompt: userMessage,
    temperature: MODEL_ROUTING["plan-generation"].temperature,
  });

  console.log("[dedalus:plan] Plan generated:", {
    operations: response.data?.operations?.length || 0,
  });

  return response.data;
}

function buildChatSystemPrompt(context: any): string {
  const assetsList = context.assets
    .map((a: any) => `- ${a.filename} (${a.type})`)
    .join("\n");

  const elementsList = context.composition?.elements
    .map((e: any) => `- ${e.type} (${e.label || e.id})`)
    .join("\n") || "No elements yet";

  return `You are ChatKut, an AI video editing assistant.

Available assets in this project:
${assetsList || "No assets uploaded yet"}

Current composition:
- Duration: ${context.composition?.metadata.durationInFrames || 0} frames
- Elements: ${context.composition?.elements.length || 0}
${elementsList}

Respond naturally to user questions about video editing. Help them add elements, apply effects, and understand their composition.`;
}

function buildEditPlanSystemPrompt(compositionIR: any): string {
  return `Generate a structured edit plan for the user's request.

Current composition:
${JSON.stringify(compositionIR, null, 2)}

Return a JSON object with this structure:
{
  "operations": [
    {
      "action": "add" | "update" | "delete" | "move",
      "selector": { "type": "byId" | "byLabel" | "byType", ... },
      "changes": { ... }
    }
  ]
}`;
}
```

3. **Update `convex/ai.ts` to Use Real SDK**

```typescript
import { action } from "./_generated/server";
import { v } from "convex/values";
import { generateChatResponse, generateEditPlan } from "../lib/dedalus/client";

export const sendChatMessage = action({
  args: {
    projectId: v.id("projects"),
    message: v.string(),
  },
  handler: async (ctx, { projectId, message }) => {
    const apiKey = process.env.DEDALUS_API_KEY!;

    // Get context
    const assets = await ctx.runQuery(internal.media.listAssets, { projectId });
    const composition = await ctx.runQuery(internal.compositions.getByProject, { projectId });
    const history = await ctx.runQuery(internal.chat.getMessages, { projectId, limit: 10 });

    // Generate response
    const response = await generateChatResponse(apiKey, message, {
      assets,
      composition,
      history,
    });

    // Save messages
    await ctx.runMutation(internal.chat.addMessage, {
      projectId,
      role: "user",
      content: message,
    });

    await ctx.runMutation(internal.chat.addMessage, {
      projectId,
      role: "assistant",
      content: response.text,
      metadata: {
        model: response.model,
        cost: response.cost,
        tokens: response.tokens,
      },
    });

    return response;
  },
});
```

**Acceptance Criteria:**
- [ ] Dedalus SDK installed and importable
- [ ] `getAIClient()` returns valid client instance
- [ ] Chat response generation works with real API
- [ ] Edit plan generation works with real API
- [ ] Cost tracking included in responses
- [ ] Model routing uses correct models per task

**Files to Update:**
- `lib/dedalus/client.ts`
- `convex/ai.ts`
- `package.json` (add dedalus-labs)

---

## Phase 2: HIGH PRIORITY (Needed for Full Functionality)

### Task 2.1: Replace Mock Remotion Cost Estimation ‚è±Ô∏è 1 hour

**Priority:** üü† HIGH - Users need accurate cost estimates

**What to Fix:**

Update `lib/remotion/lambda.ts`:

```typescript
import { estimatePrice } from "@remotion/lambda/client";

export async function estimateRenderCost(params: {
  region: string;
  durationInFrames: number;
  fps: number;
}) {
  console.log("[remotion:estimate] Estimating cost for:", params);

  const estimate = await estimatePrice({
    region: params.region || "us-east-1",
    durationInFrames: params.durationInFrames,
    fps: params.fps || 30,
    memorySizeInMb: 2048,
    diskSizeInMb: 2048,
    lambdaEfficiencyLevel: 0.8,
  });

  console.log("[remotion:estimate] Cost: $" + estimate.estimatedCost);
  console.log("[remotion:estimate] Duration: " + estimate.estimatedDuration + "ms");

  return {
    estimatedCost: estimate.estimatedCost,
    estimatedDuration: estimate.estimatedDuration,
  };
}
```

**Acceptance Criteria:**
- [ ] Uses official `estimatePrice()` API
- [ ] Returns accurate cost estimates
- [ ] Logged for debugging

**Files to Update:**
- `lib/remotion/lambda.ts`

---

### Task 2.2: Convert Next.js Pages to Async Server Components ‚è±Ô∏è 1 hour

**Priority:** üü† HIGH - Better performance & SEO

**What to Fix:**

Update `app/(dashboard)/project/[id]/page.tsx`:

```typescript
import { preloadQuery } from "convex/nextjs";
import { api } from "@/convex/_generated/api";
import ProjectDashboard from "@/components/dashboard/ProjectDashboard";

export default async function ProjectPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  // Await params (required in Next.js 14+)
  const { id } = await params;

  // Server-side parallel data fetching
  const [preloadedProject, preloadedComposition, preloadedAssets] = await Promise.all([
    preloadQuery(api.projects.get, { id }),
    preloadQuery(api.compositions.getByProject, { projectId: id }),
    preloadQuery(api.media.listAssets, { projectId: id }),
  ]);

  return (
    <ProjectDashboard
      preloadedProject={preloadedProject}
      preloadedComposition={preloadedComposition}
      preloadedAssets={preloadedAssets}
    />
  );
}
```

**Acceptance Criteria:**
- [ ] Page is async server component
- [ ] Uses `preloadQuery` for data fetching
- [ ] Awaits `params` promise
- [ ] Faster initial page load

**Files to Update:**
- `app/(dashboard)/project/[id]/page.tsx`

---

## Phase 3: TESTING & VALIDATION

### Task 3.1: Run Full Playwright Test Suite ‚è±Ô∏è 30 minutes

**Priority:** üü° MEDIUM - Validation

**What to Do:**

1. **Set up test environment variables**

Create `.env.test`:

```bash
# Copy all Convex env vars for testing
# Use test Cloudflare account if possible
```

2. **Run Playwright tests**

```bash
npm test
```

3. **Fix any failing tests**

4. **Document test results**

Create `TEST_RESULTS.md` with:
- Total tests run
- Pass/fail breakdown
- Any known issues
- Performance metrics

**Acceptance Criteria:**
- [ ] All 49 tests passing (or documented failures)
- [ ] Tests run with real credentials
- [ ] Results documented

---

## Phase 4: DOCUMENTATION & POLISH

### Task 4.1: Update All Documentation ‚è±Ô∏è 30 minutes

**Files to Update:**

1. **README.md**
   - Add environment setup instructions (Convex CLI commands)
   - Update "Getting Started" section
   - Add troubleshooting section

2. **CLAUDE.md** (already updated with Standing Orders)
   - Verify documentation-first principles are clear

3. **Create `DEPLOYMENT.md`**
   - Convex deployment steps
   - Vercel deployment steps
   - Environment variable checklist
   - Post-deployment verification

**Acceptance Criteria:**
- [ ] README.md has complete setup instructions
- [ ] DEPLOYMENT.md covers production deployment
- [ ] All docs reference correct env var approach

---

## Success Criteria Checklist

### Critical Functionality
- [ ] Convex actions access environment variables correctly
- [ ] Video upload works via TUS protocol
- [ ] Webhook signature verification passes
- [ ] AI chat returns real responses
- [ ] Edit plan generation works
- [ ] Remotion cost estimation uses official API
- [ ] Next.js pages use server components

### Testing
- [ ] 45+ Playwright tests passing
- [ ] Manual upload test passes (real video file)
- [ ] Manual chat test passes (real AI response)
- [ ] Manual render test passes (if Lambda configured)

### Documentation
- [ ] README.md has clear setup instructions
- [ ] `.env.example` explains Convex vs Next.js
- [ ] All critical gaps documented
- [ ] Troubleshooting guide exists

---

## Time Estimates

| Phase | Tasks | Estimated Time |
|-------|-------|----------------|
| **Phase 1: Critical Fixes** | 1.1 + 1.2 + 1.3 | 5.5 hours |
| **Phase 2: High Priority** | 2.1 + 2.2 | 2 hours |
| **Phase 3: Testing** | 3.1 | 30 minutes |
| **Phase 4: Documentation** | 4.1 | 30 minutes |
| **TOTAL** | | **~8.5 hours** |

---

## Next Steps

**Ready to start implementation!**

Recommended order:
1. Fix Convex env vars (30 min) - CRITICAL blocker
2. Implement Cloudflare upload (3 hours) - Core feature
3. Implement Dedalus SDK (2 hours) - AI features
4. Replace Remotion cost API (1 hour) - Better UX
5. Convert to async server components (1 hour) - Better performance
6. Run Playwright tests (30 min) - Validation
7. Update docs (30 min) - Polish

**All tasks are well-documented with code examples and acceptance criteria.**

---

## References

- `IMPLEMENTATION_GAP_ANALYSIS_V2.md` - Full gap analysis
- `REMOTION_IMPLEMENTATION.md` - Remotion patterns from official docs
- `CONVEX_IMPLEMENTATION.md` - Convex patterns from official docs
- `CONVEX_ENV_VARS.md` - Critical environment variable lesson
- `CLOUDFLARE_STREAM_IMPLEMENTATION.md` - TUS upload implementation
- `CURRENT_STATUS.md` - Current implementation status
